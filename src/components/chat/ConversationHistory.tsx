import { useState, useRef, useEffect, useCallback } from 'react'
import { createPortal } from 'react-dom'
import { useNavigate } from 'react-router-dom'
import { useTranslation } from 'react-i18next'
import { useChatStore, useThemeStore } from '../../stores'
import type { Chat, ChatFolder } from '../../stores/chatStore'
import {
  pinChat,
  moveChatToFolder,
  renameChat,
  fetchFolders,
  fetchMyChats,
  createFolder,
  updateFolderDetails,
  deleteFolder as deleteFolderApi,
  pinFolder,
} from '../../services/chat'

function formatTimeAgo(timestamp: string): string {
  const now = Date.now()
  const time = new Date(timestamp).getTime()
  const diff = now - time
  const minutes = Math.floor(diff / 60000)
  const hours = Math.floor(diff / 3600000)
  const days = Math.floor(diff / 86400000)

  if (minutes < 1) return 'just now'
  if (minutes < 60) return `${minutes}m ago`
  if (hours < 24) return `${hours}h ago`
  if (days < 7) return `${days}d ago`
  return new Date(timestamp).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
}

function getChatDisplayTitle(chat: Chat): string {
  if (chat.autoGeneratedTitle && isGenericName(chat.name)) {
    return chat.autoGeneratedTitle
  }
  return chat.name || 'Untitled'
}

function isGenericName(name: string | null | undefined): boolean {
  if (!name) return true
  const genericPatterns = [
    /^new chat$/i,
    /^untitled$/i,
    /^chat$/i,
    /^conversation$/i,
    /^\d{4}-\d{2}-\d{2}/,
    /^chat #?\d+$/i,
  ]
  return genericPatterns.some((pattern) => pattern.test(name.trim()))
}

// Pin icon component
function PinIcon({ filled, className }: { filled?: boolean; className?: string }) {
  return (
    <svg className={className} viewBox="0 0 24 24" fill={filled ? 'currentColor' : 'none'} stroke="currentColor" strokeWidth={2}>
      <path d="M12 2v8m0 0l-4-2m4 2l4-2M8 22l4-8 4 8" strokeLinecap="round" strokeLinejoin="round" />
    </svg>
  )
}

// Folder icon component
function FolderIcon({ open, className }: { open?: boolean; className?: string }) {
  return open ? (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 19a2 2 0 01-2-2V7a2 2 0 012-2h4l2 2h4a2 2 0 012 2v1M5 19h14a2 2 0 002-2v-5a2 2 0 00-2-2H9a2 2 0 00-2 2v5a2 2 0 01-2 2z" />
    </svg>
  ) : (
    <svg className={className} fill="none" stroke="currentColor" viewBox="0 0 24 24">
      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z" />
    </svg>
  )
}

interface ContextMenuProps {
  x: number
  y: number
  theme: string
  onClose: () => void
  onPin: () => void
  onUnpin: () => void
  onRename: () => void
  onMoveToFolder: (folderId: string | null) => void
  onDelete: () => void
  isPinned: boolean
  folders: ChatFolder[]
  currentFolderId?: string
  isFolder?: boolean
}

function ContextMenu({
  x,
  y,
  theme,
  onClose,
  onPin,
  onUnpin,
  onRename,
  onMoveToFolder,
  onDelete,
  isPinned,
  folders,
  currentFolderId,
  isFolder,
}: ContextMenuProps) {
  const availableFolders = folders.filter(f => f.id !== currentFolderId)

  return (
    <>
      {/* Backdrop - catches clicks outside context menu */}
      <div
        className="fixed inset-0 z-[49]"
        onClick={onClose}
      />
      <div
        className={`fixed z-50 shadow-xl py-1 min-w-40 ${
          theme === 'dark' ? 'bg-juice-dark border border-white/20' : 'bg-white border border-gray-200'
        }`}
        style={{ left: x, top: y }}
        onClick={(e) => e.stopPropagation()}
      >
      {/* Pin/Unpin */}
      <button
        onClick={isPinned ? onUnpin : onPin}
        className={`w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 ${
          theme === 'dark'
            ? 'text-gray-300 hover:bg-gray-700'
            : 'text-gray-700 hover:bg-gray-100'
        }`}
      >
        <PinIcon filled={isPinned} className="w-4 h-4" />
        {isPinned ? 'Unpin' : 'Pin'}
      </button>

      {/* Rename */}
      <button
        onClick={onRename}
        className={`w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 ${
          theme === 'dark'
            ? 'text-gray-300 hover:bg-gray-700'
            : 'text-gray-700 hover:bg-gray-100'
        }`}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
        </svg>
        Rename
      </button>

      {/* Move to folder (only for chats) */}
      {!isFolder && (
        <>
          <div className={`border-t my-1 ${theme === 'dark' ? 'border-gray-700' : 'border-gray-200'}`} />
          <div className={`px-3 py-1 text-xs font-medium ${
            theme === 'dark' ? 'text-gray-500' : 'text-gray-400'
          }`}>
            Move to...
          </div>
          {currentFolderId && (
            <button
              onClick={() => onMoveToFolder(null)}
              className={`w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 ${
                theme === 'dark'
                  ? 'text-gray-300 hover:bg-gray-700'
                  : 'text-gray-700 hover:bg-gray-100'
              }`}
            >
              <span className="w-4" />
              No folder
            </button>
          )}
          {availableFolders.map(folder => (
            <button
              key={folder.id}
              onClick={() => onMoveToFolder(folder.id)}
              className={`w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 ${
                theme === 'dark'
                  ? 'text-gray-300 hover:bg-gray-700'
                  : 'text-gray-700 hover:bg-gray-100'
              }`}
            >
              <FolderIcon className="w-4 h-4" />
              {folder.name}
            </button>
          ))}
        </>
      )}

      {/* Delete */}
      <div className={`border-t my-1 ${theme === 'dark' ? 'border-gray-700' : 'border-gray-200'}`} />
      <button
        onClick={onDelete}
        className={`w-full text-left px-3 py-1.5 text-sm flex items-center gap-2 ${
          theme === 'dark'
            ? 'text-red-400 hover:bg-gray-700'
            : 'text-red-600 hover:bg-gray-100'
        }`}
      >
        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
        Delete
      </button>
    </div>
    </>
  )
}

interface RenameModalProps {
  isOpen: boolean
  currentName: string
  onClose: () => void
  onSave: (newName: string) => void
  theme: string
}

function RenameModal({ isOpen, currentName, onClose, onSave, theme }: RenameModalProps) {
  const [name, setName] = useState(currentName)
  const inputRef = useRef<HTMLInputElement>(null)

  useEffect(() => {
    if (isOpen) {
      setName(currentName)
      setTimeout(() => inputRef.current?.select(), 0)
    }
  }, [isOpen, currentName])

  if (!isOpen) return null

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (name.trim()) {
      onSave(name.trim())
    }
  }

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black/50" onClick={onClose}>
      <div
        className={`p-4 min-w-72 border shadow-xl ${
          theme === 'dark' ? 'bg-juice-dark border-white/20' : 'bg-white border-gray-200'
        }`}
        onClick={(e) => e.stopPropagation()}
      >
        <h3 className={`text-sm font-medium mb-3 ${
          theme === 'dark' ? 'text-gray-200' : 'text-gray-800'
        }`}>
          Rename
        </h3>
        <form onSubmit={handleSubmit}>
          <input
            ref={inputRef}
            type="text"
            value={name}
            onChange={(e) => setName(e.target.value)}
            className={`w-full px-4 py-2.5 text-sm border ${
              theme === 'dark'
                ? 'bg-juice-dark-lighter border-white/10 text-white focus:border-white/30'
                : 'bg-white border-gray-300 text-gray-900 focus:border-gray-400'
            } focus:outline-none`}
            autoFocus
          />
          <div className="flex justify-end gap-2 mt-3">
            <button
              type="button"
              onClick={onClose}
              className={`px-3 py-1.5 text-sm transition-colors ${
                theme === 'dark'
                  ? 'text-gray-300 hover:text-white hover:bg-white/10'
                  : 'text-gray-600 hover:text-gray-900 hover:bg-gray-100'
              }`}
            >
              Cancel
            </button>
            <button
              type="submit"
              className={`px-3 py-1.5 text-sm font-medium transition-colors border ${
                theme === 'dark'
                  ? 'border-green-500 text-green-500 hover:bg-green-500/10'
                  : 'border-green-600 text-green-600 hover:bg-green-600/10'
              }`}
            >
              Save
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}

const PAGE_SIZE = 10

export default function ConversationHistory() {
  const { theme } = useThemeStore()
  const { t } = useTranslation()
  const navigate = useNavigate()
  const {
    chats,
    folders,
    activeChatId,
    setActiveChat,
    removeChat,
    updateChat,
    setChats,
    setFolders,
    addFolder,
    updateFolder,
    removeFolder,
    getPinnedFolders,
    getChatsInFolder,
    getSubfolders,
  } = useChatStore()

  const [contextMenu, setContextMenu] = useState<{
    type: 'chat' | 'folder'
    id: string
    x: number
    y: number
  } | null>(null)
  const [renameModal, setRenameModal] = useState<{
    type: 'chat' | 'folder'
    id: string
    currentName: string
  } | null>(null)
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set())
  const [folderPopover, setFolderPopover] = useState<{ top: number; left: number; above: boolean } | null>(null)
  const [newFolderName, setNewFolderName] = useState('')
  const folderPopoverRef = useRef<HTMLDivElement>(null)

  // Pagination state
  const [totalChats, setTotalChats] = useState(0)
  const [isLoading, setIsLoading] = useState(false)
  const [hasMore, setHasMore] = useState(true)
  const loadMoreRef = useRef<HTMLDivElement>(null)

  // Load chats with pagination
  const loadChats = useCallback(async (offset: number, append: boolean = false) => {
    if (isLoading) return
    setIsLoading(true)
    try {
      const { chats: newChats, total } = await fetchMyChats({ limit: PAGE_SIZE, offset })
      setTotalChats(total)
      setHasMore(offset + newChats.length < total)
      if (append) {
        // Append to existing chats, avoiding duplicates
        const existingIds = new Set(chats.map(c => c.id))
        const uniqueNewChats = newChats.filter(c => !existingIds.has(c.id))
        setChats([...chats, ...uniqueNewChats])
      } else {
        setChats(newChats)
      }
    } catch (error) {
      console.error('Failed to load chats:', error)
    } finally {
      setIsLoading(false)
    }
  }, [isLoading, setChats, chats])

  // Load initial data
  useEffect(() => {
    fetchFolders().then(setFolders).catch(console.error)
    loadChats(0)
  }, [setFolders]) // eslint-disable-line react-hooks/exhaustive-deps

  // Intersection observer for infinite scroll
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting && hasMore && !isLoading) {
          loadChats(chats.length, true)
        }
      },
      { threshold: 0.1 }
    )

    if (loadMoreRef.current) {
      observer.observe(loadMoreRef.current)
    }

    return () => observer.disconnect()
  }, [hasMore, isLoading, chats.length, loadChats])

  const closeFolderPopover = () => {
    setFolderPopover(null)
    setNewFolderName('')
  }

  // Get organized data
  const pinnedFolders = getPinnedFolders()
  const rootFolders = getSubfolders(null)
  const rootChats = getChatsInFolder(null)

  // Filter to only chats with messages
  const nonEmptyChats = chats.filter(c => c.messages && c.messages.length > 0)

  if (nonEmptyChats.length === 0 && folders.length === 0 && !isLoading) return null

  const handleSelectChat = (id: string) => {
    setActiveChat(id)
    navigate(`/chat/${id}`)
  }

  const handleContextMenu = (e: React.MouseEvent, type: 'chat' | 'folder', id: string) => {
    e.preventDefault()
    e.stopPropagation()
    setContextMenu({ type, id, x: e.clientX, y: e.clientY })
  }

  const handleCloseContextMenu = () => setContextMenu(null)

  const handlePin = async () => {
    if (!contextMenu) return
    try {
      if (contextMenu.type === 'chat') {
        const updated = await pinChat(contextMenu.id, true)
        updateChat(contextMenu.id, { isPinned: updated.isPinned, pinOrder: updated.pinOrder })
      } else {
        const updated = await pinFolder(contextMenu.id, true)
        updateFolder(contextMenu.id, { isPinned: updated.isPinned, pinOrder: updated.pinOrder })
      }
    } catch (error) {
      console.error('Failed to pin:', error)
    }
    setContextMenu(null)
  }

  const handleUnpin = async () => {
    if (!contextMenu) return
    try {
      if (contextMenu.type === 'chat') {
        const updated = await pinChat(contextMenu.id, false)
        updateChat(contextMenu.id, { isPinned: updated.isPinned, pinOrder: undefined })
      } else {
        const updated = await pinFolder(contextMenu.id, false)
        updateFolder(contextMenu.id, { isPinned: updated.isPinned, pinOrder: undefined })
      }
    } catch (error) {
      console.error('Failed to unpin:', error)
    }
    setContextMenu(null)
  }

  const handleOpenRename = () => {
    if (!contextMenu) return
    if (contextMenu.type === 'chat') {
      const chat = chats.find(c => c.id === contextMenu.id)
      if (chat) {
        setRenameModal({ type: 'chat', id: chat.id, currentName: getChatDisplayTitle(chat) })
      }
    } else {
      const folder = folders.find(f => f.id === contextMenu.id)
      if (folder) {
        setRenameModal({ type: 'folder', id: folder.id, currentName: folder.name })
      }
    }
    setContextMenu(null)
  }

  const handleRename = async (newName: string) => {
    if (!renameModal) return
    try {
      if (renameModal.type === 'chat') {
        const updated = await renameChat(renameModal.id, newName)
        updateChat(renameModal.id, { name: updated.name })
      } else {
        const updated = await updateFolderDetails(renameModal.id, { name: newName })
        updateFolder(renameModal.id, { name: updated.name })
      }
    } catch (error) {
      console.error('Failed to rename:', error)
    }
    setRenameModal(null)
  }

  const handleMoveToFolder = async (folderId: string | null) => {
    if (!contextMenu || contextMenu.type !== 'chat') return
    try {
      const updated = await moveChatToFolder(contextMenu.id, folderId)
      updateChat(contextMenu.id, { folderId: updated.folderId })
    } catch (error) {
      console.error('Failed to move chat:', error)
    }
    setContextMenu(null)
  }

  const handleDelete = async () => {
    if (!contextMenu) return
    if (contextMenu.type === 'chat') {
      removeChat(contextMenu.id)
    } else {
      try {
        await deleteFolderApi(contextMenu.id)
        removeFolder(contextMenu.id)
      } catch (error) {
        console.error('Failed to delete folder:', error)
      }
    }
    setContextMenu(null)
  }

  const toggleFolder = (folderId: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev)
      if (next.has(folderId)) {
        next.delete(folderId)
      } else {
        next.add(folderId)
      }
      return next
    })
  }

  const handleCreateFolder = async () => {
    if (!newFolderName.trim()) return
    try {
      const folder = await createFolder(newFolderName.trim())
      addFolder(folder)
      setNewFolderName('')
      setFolderPopover(null)
    } catch (error) {
      console.error('Failed to create folder:', error)
    }
  }

  const openFolderPopover = (e: React.MouseEvent<HTMLButtonElement>) => {
    const rect = e.currentTarget.getBoundingClientRect()
    // If button is in bottom half of page, show popover above it
    const inBottomHalf = rect.top > window.innerHeight / 2
    setFolderPopover({
      top: inBottomHalf ? rect.top : rect.bottom,
      left: rect.left,
      above: inBottomHalf,
    })
  }

  const getContextItem = () => {
    if (!contextMenu) return null
    if (contextMenu.type === 'chat') {
      return chats.find(c => c.id === contextMenu.id)
    }
    return folders.find(f => f.id === contextMenu.id)
  }

  const contextItem = getContextItem()

  // Render a chat item
  const renderChat = (chat: Chat, indent = 0) => (
    <div
      key={chat.id}
      onClick={() => handleSelectChat(chat.id)}
      onContextMenu={(e) => handleContextMenu(e, 'chat', chat.id)}
      style={{ paddingLeft: indent > 0 ? `${indent * 16}px` : undefined }}
      className={`group flex items-center justify-between py-1.5 pr-2 rounded cursor-pointer transition-colors ${
        chat.id === activeChatId
          ? theme === 'dark'
            ? 'bg-white/5 text-white'
            : 'bg-gray-100 text-gray-900'
          : theme === 'dark'
            ? 'text-gray-400 hover:text-gray-200 hover:bg-white/5'
            : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'
      }`}
    >
      <div className="flex items-center gap-2 flex-1 min-w-0">
        {chat.isPinned && (
          <PinIcon filled className={`w-3 h-3 shrink-0 ${
            theme === 'dark' ? 'text-purple-400' : 'text-purple-600'
          }`} />
        )}
        <div className="flex-1 min-w-0">
          <div className={`text-sm truncate ${
            chat.id === activeChatId ? '' : theme === 'dark' ? 'text-gray-300' : 'text-gray-700'
          }`}>
            {getChatDisplayTitle(chat)}
          </div>
          <div className={`text-xs ${theme === 'dark' ? 'text-gray-600' : 'text-gray-400'}`}>
            {formatTimeAgo(chat.updatedAt)}
          </div>
        </div>
      </div>
      {/* Trash button - visible on hover */}
      <button
        onClick={(e) => {
          e.stopPropagation()
          removeChat(chat.id)
        }}
        className={`shrink-0 p-1 opacity-0 group-hover:opacity-100 transition-opacity ${
          theme === 'dark'
            ? 'text-gray-600 hover:text-red-400'
            : 'text-gray-300 hover:text-red-500'
        }`}
        title="Delete"
      >
        <svg className="w-3.5 h-3.5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
        </svg>
      </button>
    </div>
  )

  // Render a folder item
  const renderFolder = (folder: ChatFolder, indent = 0) => {
    const isExpanded = expandedFolders.has(folder.id)
    const folderChats = getChatsInFolder(folder.id).filter(c => c.messages && c.messages.length > 0)
    const subfolders = getSubfolders(folder.id)

    return (
      <div key={folder.id}>
        <div
          onClick={() => toggleFolder(folder.id)}
          onContextMenu={(e) => handleContextMenu(e, 'folder', folder.id)}
          style={{ paddingLeft: indent > 0 ? `${indent * 16}px` : undefined }}
          className={`group flex items-center gap-2 py-1.5 pr-2 rounded cursor-pointer transition-colors ${
            theme === 'dark'
              ? 'text-gray-400 hover:text-gray-200 hover:bg-white/5'
              : 'text-gray-500 hover:text-gray-700 hover:bg-gray-50'
          }`}
        >
          <svg
            className={`w-3 h-3 shrink-0 transition-transform ${isExpanded ? 'rotate-90' : ''}`}
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
          {folder.isPinned && (
            <PinIcon filled className={`w-3 h-3 shrink-0 ${
              theme === 'dark' ? 'text-purple-400' : 'text-purple-600'
            }`} />
          )}
          <FolderIcon open={isExpanded} className="w-4 h-4 shrink-0" />
          <span className="text-sm truncate">{folder.name}</span>
          <span className={`text-xs ${theme === 'dark' ? 'text-gray-600' : 'text-gray-400'}`}>
            ({folderChats.length})
          </span>
        </div>
        {isExpanded && (
          <div>
            {subfolders.map(sub => renderFolder(sub, indent + 1))}
            {folderChats.map(chat => renderChat(chat, indent + 1))}
          </div>
        )}
      </div>
    )
  }

  return (
    <div className="pl-[84px] pr-6 mt-8">
      {/* Header with create folder button beside title */}
      <div className="flex items-center gap-3 mb-2">
        <span className={`text-xs font-medium ${
          theme === 'dark' ? 'text-gray-500' : 'text-gray-400'
        }`}>
          {t('ui.recent', 'Recent')} ({totalChats || nonEmptyChats.length})
        </span>
        <button
          onClick={openFolderPopover}
          className={`text-xs px-2 py-1 border transition-colors ${
            theme === 'dark'
              ? 'border-white/10 text-gray-400 hover:text-white hover:border-white/20'
              : 'border-gray-200 text-gray-500 hover:text-gray-700 hover:border-gray-300'
          }`}
        >
          {t('ui.newFolder', 'New folder')}
        </button>
      </div>

      {/* Folder creation popover - rendered via portal to escape backdrop-blur containing block */}
      {folderPopover && createPortal(
        <>
          {/* Backdrop - catches clicks outside popover */}
          <div
            className="fixed inset-0 z-[49]"
            onClick={closeFolderPopover}
          />
          <div
            ref={folderPopoverRef}
            className={`fixed z-50 p-3 shadow-xl ${
              theme === 'dark' ? 'bg-juice-dark border border-white/20' : 'bg-white border border-gray-200'
            }`}
            style={{
              left: folderPopover.left,
              ...(folderPopover.above
                ? { bottom: window.innerHeight - folderPopover.top + 4 }
                : { top: folderPopover.top + 4 }),
            }}
          >
            <div className="flex gap-2">
              <input
                type="text"
                value={newFolderName}
                onChange={(e) => setNewFolderName(e.target.value)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') handleCreateFolder()
                  if (e.key === 'Escape') closeFolderPopover()
                }}
                placeholder="Folder name..."
                className={`w-40 px-3 py-1.5 text-sm border ${
                  theme === 'dark'
                    ? 'bg-juice-dark-lighter border-white/10 text-white placeholder-gray-500 focus:border-white/30'
                    : 'bg-white border-gray-300 text-gray-900 placeholder-gray-400 focus:border-gray-400'
                } focus:outline-none`}
                autoFocus
              />
              <button
                onClick={handleCreateFolder}
                className={`px-3 py-1.5 text-sm font-medium transition-colors border ${
                  theme === 'dark'
                    ? 'border-green-500 text-green-500 hover:bg-green-500/10'
                    : 'border-green-600 text-green-600 hover:bg-green-600/10'
                }`}
              >
                Create
              </button>
            </div>
          </div>
        </>,
        document.body
      )}

      {/* Chat and folder list */}
      <div className="space-y-0.5">
        {/* Pinned folders first */}
        {pinnedFolders.map(folder => renderFolder(folder))}

        {/* Regular folders */}
        {rootFolders.filter(f => !f.isPinned).map(folder => renderFolder(folder))}

        {/* Root-level chats (not in any folder) */}
        {rootChats
          .filter(c => c.messages && c.messages.length > 0)
          .map(chat => renderChat(chat))}

        {/* Load more trigger */}
        {hasMore && (
          <div
            ref={loadMoreRef}
            className={`py-3 text-center text-xs ${
              theme === 'dark' ? 'text-gray-500' : 'text-gray-400'
            }`}
          >
            {isLoading ? 'Loading...' : ''}
          </div>
        )}
      </div>

      {/* Context menu */}
      {contextMenu && contextItem && (
        <ContextMenu
          x={contextMenu.x}
          y={contextMenu.y}
          theme={theme}
          onClose={handleCloseContextMenu}
          onPin={handlePin}
          onUnpin={handleUnpin}
          onRename={handleOpenRename}
          onMoveToFolder={handleMoveToFolder}
          onDelete={handleDelete}
          isPinned={'isPinned' in contextItem ? contextItem.isPinned : false}
          folders={folders}
          currentFolderId={contextMenu.type === 'chat' ? (contextItem as Chat).folderId : undefined}
          isFolder={contextMenu.type === 'folder'}
        />
      )}

      {/* Rename modal */}
      <RenameModal
        isOpen={!!renameModal}
        currentName={renameModal?.currentName ?? ''}
        onClose={() => setRenameModal(null)}
        onSave={handleRename}
        theme={theme}
      />
    </div>
  )
}
