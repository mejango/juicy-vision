import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Types matching backend API
export interface ChatMember {
  address: string
  userId?: string
  role: 'founder' | 'admin' | 'member'
  displayName?: string
  customEmoji?: string
  joinedAt: string
  canSendMessages?: boolean
  canInvite?: boolean
  canInvokeAi?: boolean
  canManageMembers?: boolean
  canPauseAi?: boolean
}

/**
 * Chat Permission Levels:
 * 1. view-only: Can only read messages (canSendMessages=false)
 * 2. view-and-write: Can read and send messages (canSendMessages=true, canInvite=false)
 * 3. view-and-write-and-invite: Can read, send, and create invites (canInvite=true)
 * 4. view-and-write-and-invite-and-caninvite: Full permissions, can create invites that grant invite permission
 */
export type ChatPermissionLevel =
  | 'view-only'
  | 'view-and-write'
  | 'view-and-write-and-invite'
  | 'view-and-write-and-invite-and-caninvite'

export function getMemberPermissionLevel(member: ChatMember): ChatPermissionLevel {
  if (member.canSendMessages === false) {
    return 'view-only'
  }
  if (!member.canInvite) {
    return 'view-and-write'
  }
  // Founders and admins always have full permissions
  if (member.role === 'founder' || member.role === 'admin') {
    return 'view-and-write-and-invite-and-caninvite'
  }
  return 'view-and-write-and-invite'
}

export interface ChatMessage {
  id: string
  chatId: string
  senderAddress: string
  senderUserId?: string
  role: 'user' | 'assistant' | 'system'
  content: string
  isEncrypted: boolean
  replyToId?: string
  createdAt: string
  isStreaming?: boolean
  attachments?: Attachment[]
}

export interface ChatFolder {
  id: string
  userAddress: string
  userId?: string
  name: string
  parentFolderId?: string
  isPinned: boolean
  pinOrder?: number
  createdAt: string
  updatedAt: string
}

export interface Chat {
  id: string
  founderAddress: string
  founderUserId?: string
  name: string
  description?: string
  isPublic: boolean
  isPrivate: boolean // When true, chat won't be stored for study/improvement
  aiBalanceWei: string
  aiTotalSpentWei: string
  encrypted: boolean
  encryptionVersion: number
  tokenGateEnabled?: boolean
  tokenGateChainId?: number
  tokenGateTokenAddress?: string
  tokenGateMinBalance?: string
  archivedCid?: string
  // AI toggle - global chat-level setting
  aiEnabled?: boolean
  // Organization fields
  isPinned: boolean
  pinOrder?: number
  folderId?: string
  autoGeneratedTitle?: string
  createdAt: string
  updatedAt: string
  // Local state
  members?: ChatMember[]
  messages?: ChatMessage[]
  unreadCount?: number
  onlineMembers?: string[] // Addresses of currently connected members
}

export interface CreateChatParams {
  name: string
  description?: string
  isPublic?: boolean
  isPrivate?: boolean // When true, chat won't be stored for study/improvement
  encrypted?: boolean
  tokenGate?: {
    chainId: number
    tokenAddress: string
    minBalance: string
  }
}

interface ChatState {
  // State
  chats: Chat[]
  folders: ChatFolder[]
  activeChatId: string | null
  waitingForAiChatId: string | null  // Track which chat is waiting for AI response (persists across navigation)
  pendingNewChat: boolean  // True when creating a new chat - keeps UI in chat mode during transition
  pendingMessage: string | null  // Message content for pending new chat (for optimistic display)
  queuedNewChatMessage: string | null  // Message queued from another page (e.g., project page) to send on mount
  isLoading: boolean
  isConnected: boolean
  error: string | null

  // Chat actions
  setChats: (chats: Chat[]) => void
  addChat: (chat: Chat) => void
  updateChat: (chatId: string, updates: Partial<Chat>) => void
  removeChat: (chatId: string) => void
  setActiveChat: (chatId: string | null) => void
  getActiveChat: () => Chat | undefined

  // Organization helpers
  getPinnedChats: () => Chat[]
  getChatsInFolder: (folderId: string | null) => Chat[]
  getRecentChats: () => Chat[] // All chats sorted by updated_at

  // Folder actions
  setFolders: (folders: ChatFolder[]) => void
  addFolder: (folder: ChatFolder) => void
  updateFolder: (folderId: string, updates: Partial<ChatFolder>) => void
  removeFolder: (folderId: string) => void
  getPinnedFolders: () => ChatFolder[]
  getSubfolders: (parentFolderId: string | null) => ChatFolder[]

  // Message actions
  addMessage: (chatId: string, message: ChatMessage) => void
  updateMessage: (chatId: string, messageId: string, updates: Partial<Pick<ChatMessage, 'content' | 'isStreaming'>>) => void
  setMessages: (chatId: string, messages: ChatMessage[]) => void

  // Member actions
  setMembers: (chatId: string, members: ChatMember[]) => void
  addMember: (chatId: string, member: ChatMember) => void
  updateMember: (chatId: string, address: string, updates: Partial<ChatMember>) => void
  removeMember: (chatId: string, address: string) => void

  // Online presence
  setOnlineMembers: (chatId: string, addresses: string[]) => void
  updatePresence: (chatId: string, address: string, isOnline: boolean) => void

  // UI state
  setLoading: (loading: boolean) => void
  setConnected: (connected: boolean) => void
  setError: (error: string | null) => void
  clearUnread: (chatId: string) => void
  incrementUnread: (chatId: string) => void
  setWaitingForAiChatId: (chatId: string | null) => void
  setPendingNewChat: (pending: boolean, message?: string | null) => void
  setQueuedNewChatMessage: (message: string | null) => void
}

export const useChatStore = create<ChatState>()(
  persist(
    (set, get) => ({
      chats: [],
      folders: [],
      activeChatId: null,
      waitingForAiChatId: null,
      pendingNewChat: false,
      pendingMessage: null,
      queuedNewChatMessage: null,
      isLoading: false,
      isConnected: false,
      error: null,

      setChats: (chats) => set({ chats }),

      addChat: (chat) =>
        set((state) => ({
          chats: [chat, ...state.chats.filter((c) => c.id !== chat.id)],
        })),

      updateChat: (chatId, updates) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, ...updates } : c
          ),
        })),

      removeChat: (chatId) =>
        set((state) => ({
          chats: state.chats.filter((c) => c.id !== chatId),
          activeChatId:
            state.activeChatId === chatId ? null : state.activeChatId,
        })),

      setActiveChat: (chatId) => set({ activeChatId: chatId }),

      getActiveChat: () => {
        const state = get()
        return state.chats.find((c) => c.id === state.activeChatId)
      },

      // Organization helpers
      getPinnedChats: () => {
        const state = get()
        return state.chats
          .filter((c) => c && c.isPinned)
          .sort((a, b) => (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity))
      },

      getChatsInFolder: (folderId) => {
        const state = get()
        return state.chats
          .filter((c) => c && (folderId === null ? !c.folderId : c.folderId === folderId))
          .sort((a, b) => {
            // Pinned first, then by updated_at
            if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
            if (a.isPinned && b.isPinned) {
              return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
            }
            return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          })
      },

      getRecentChats: () => {
        const state = get()
        return state.chats.filter(Boolean).sort((a, b) => {
          // Pinned first, then by updated_at
          if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
          if (a.isPinned && b.isPinned) {
            return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
          }
          return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
        })
      },

      // Folder actions
      setFolders: (folders) => set({ folders }),

      addFolder: (folder) =>
        set((state) => ({
          folders: [folder, ...state.folders.filter((f) => f.id !== folder.id)],
        })),

      updateFolder: (folderId, updates) =>
        set((state) => ({
          folders: state.folders.map((f) =>
            f.id === folderId ? { ...f, ...updates } : f
          ),
        })),

      removeFolder: (folderId) =>
        set((state) => ({
          folders: state.folders.filter((f) => f.id !== folderId),
        })),

      getPinnedFolders: () => {
        const state = get()
        return state.folders
          .filter((f) => f.isPinned)
          .sort((a, b) => (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity))
      },

      getSubfolders: (parentFolderId) => {
        const state = get()
        return state.folders
          .filter((f) => parentFolderId === null ? !f.parentFolderId : f.parentFolderId === parentFolderId)
          .sort((a, b) => {
            // Pinned first, then by name
            if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
            if (a.isPinned && b.isPinned) {
              return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
            }
            return a.name.localeCompare(b.name)
          })
      },

      // Messages
      addMessage: (chatId, message) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const messages = c.messages || []
            // Avoid duplicates by ID
            if (messages.some((m) => m.id === message.id)) return c
            // For user messages, check if there's an optimistic match to replace
            if (message.role === 'user') {
              const optimisticIdx = messages.findIndex((m) =>
                m.role === 'user' &&
                m.content === message.content &&
                Math.abs(new Date(m.createdAt).getTime() - new Date(message.createdAt).getTime()) < 30000
              )
              if (optimisticIdx !== -1) {
                // Server message has CID-based attachments â€” replace the optimistic one
                const updated = [...messages]
                updated[optimisticIdx] = message
                return { ...c, messages: updated }
              }
            }
            return { ...c, messages: [...messages, message] }
          }),
        })),

      updateMessage: (chatId, messageId, updates) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              messages: (c.messages || []).map((m) =>
                m.id === messageId ? { ...m, ...updates } : m
              ),
            }
          }),
        })),

      setMessages: (chatId, messages) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return { ...c, messages }
          }),
        })),

      // Members
      setMembers: (chatId, members) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, members } : c
          ),
        })),

      addMember: (chatId, member) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const members = c.members || []
            // Case-insensitive address comparison (Ethereum addresses can have different casing)
            if (members.some((m) => m.address?.toLowerCase() === member.address?.toLowerCase())) return c
            return { ...c, members: [...members, member] }
          }),
        })),

      updateMember: (chatId, address, updates) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              members: (c.members || []).map((m) =>
                m.address?.toLowerCase() === address?.toLowerCase()
                  ? { ...m, ...updates }
                  : m
              ),
            }
          }),
        })),

      removeMember: (chatId, address) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              // Case-insensitive address comparison
              members: (c.members || []).filter((m) => m.address?.toLowerCase() !== address?.toLowerCase()),
            }
          }),
        })),

      // Online presence
      setOnlineMembers: (chatId, addresses) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, onlineMembers: addresses } : c
          ),
        })),

      updatePresence: (chatId, address, isOnline) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const current = c.onlineMembers || []
            const addressLower = address?.toLowerCase()
            const updated = isOnline
              ? current.some(a => a?.toLowerCase() === addressLower) ? current : [...current, address]
              : current.filter((a) => a?.toLowerCase() !== addressLower)
            return { ...c, onlineMembers: updated }
          }),
        })),

      // UI state
      setLoading: (isLoading) => set({ isLoading }),
      setConnected: (isConnected) => set({ isConnected }),
      setError: (error) => set({ error }),

      clearUnread: (chatId) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, unreadCount: 0 } : c
          ),
        })),

      incrementUnread: (chatId) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId
              ? { ...c, unreadCount: (c.unreadCount || 0) + 1 }
              : c
          ),
        })),

      setWaitingForAiChatId: (chatId) => set({ waitingForAiChatId: chatId }),
      setPendingNewChat: (pending, message = null) => set({ pendingNewChat: pending, pendingMessage: message }),
      setQueuedNewChatMessage: (message) => set({ queuedNewChatMessage: message }),
    }),
    {
      name: 'juice-chat',
      partialize: (state) => ({
        // Only persist chats, folders, and activeChatId, not loading/error states
        // Strip base64 data from attachments to avoid localStorage quota issues
        // Keep CID-based attachments (small strings, safe for localStorage)
        // Filter out null chats that can occur during test cleanup
        chats: state.chats.filter(Boolean).map(chat => ({
          ...chat,
          messages: chat.messages?.map(msg => {
            if (!msg.attachments || msg.attachments.length === 0) return msg
            // Keep only CID-based attachments, strip base64 data
            const persistedAttachments = msg.attachments
              .filter(a => a.cid)
              .map(({ data: _data, ...rest }) => rest)
            return persistedAttachments.length > 0
              ? { ...msg, attachments: persistedAttachments }
              : (() => { const { attachments: _att, ...rest } = msg; return rest })()
          }),
        })),
        folders: state.folders,
        activeChatId: state.activeChatId,
      }),
    }
  )
)

// Display types for UI components
export interface Attachment {
  id: string
  type: 'image' | 'document'
  name: string
  mimeType: string
  data?: string  // base64 (only for local/optimistic messages)
  cid?: string   // IPFS CID (for persisted messages)
}

export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp?: number
  isStreaming?: boolean
  attachments?: Attachment[]
  senderName?: string
  senderAddress?: string
  createdAt?: string
  needsJuicyId?: boolean // Show "Add your Juicy ID" prompt instead of sender name
}

export interface Conversation {
  id: string
  title: string
  messages: Message[]
  createdAt: number
  updatedAt: number
}

