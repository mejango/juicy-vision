import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// Types matching backend API
export interface ChatMember {
  address: string
  userId?: string
  role: 'founder' | 'admin' | 'member'
  displayName?: string
  customEmoji?: string
  joinedAt: string
  canSendMessages?: boolean
  canInvite?: boolean
  canInvokeAi?: boolean
  canManageMembers?: boolean
  canPauseAi?: boolean
}

/**
 * Chat Permission Levels:
 * 1. view-only: Can only read messages (canSendMessages=false)
 * 2. view-and-write: Can read and send messages (canSendMessages=true, canInvite=false)
 * 3. view-and-write-and-invite: Can read, send, and create invites (canInvite=true)
 * 4. view-and-write-and-invite-and-caninvite: Full permissions, can create invites that grant invite permission
 */
export type ChatPermissionLevel =
  | 'view-only'
  | 'view-and-write'
  | 'view-and-write-and-invite'
  | 'view-and-write-and-invite-and-caninvite'

export function getMemberPermissionLevel(member: ChatMember): ChatPermissionLevel {
  if (member.canSendMessages === false) {
    return 'view-only'
  }
  if (!member.canInvite) {
    return 'view-and-write'
  }
  // Founders and admins always have full permissions
  if (member.role === 'founder' || member.role === 'admin') {
    return 'view-and-write-and-invite-and-caninvite'
  }
  return 'view-and-write-and-invite'
}

export interface ChatMessage {
  id: string
  chatId: string
  senderAddress: string
  senderUserId?: string
  role: 'user' | 'assistant' | 'system'
  content: string
  isEncrypted: boolean
  replyToId?: string
  createdAt: string
  isStreaming?: boolean
  attachments?: Attachment[]
}

export interface ChatFolder {
  id: string
  userAddress: string
  userId?: string
  name: string
  parentFolderId?: string
  isPinned: boolean
  pinOrder?: number
  createdAt: string
  updatedAt: string
}

export interface Chat {
  id: string
  founderAddress: string
  founderUserId?: string
  name: string
  description?: string
  isPublic: boolean
  aiBalanceWei: string
  aiTotalSpentWei: string
  encrypted: boolean
  encryptionVersion: number
  tokenGateEnabled?: boolean
  tokenGateChainId?: number
  tokenGateTokenAddress?: string
  tokenGateMinBalance?: string
  archivedCid?: string
  // AI toggle - global chat-level setting
  aiEnabled?: boolean
  // Organization fields
  isPinned: boolean
  pinOrder?: number
  folderId?: string
  autoGeneratedTitle?: string
  createdAt: string
  updatedAt: string
  // Local state
  members?: ChatMember[]
  messages?: ChatMessage[]
  unreadCount?: number
  onlineMembers?: string[] // Addresses of currently connected members
}

export interface CreateChatParams {
  name: string
  description?: string
  isPublic?: boolean
  encrypted?: boolean
  tokenGate?: {
    chainId: number
    tokenAddress: string
    minBalance: string
  }
}

interface ChatState {
  // State
  chats: Chat[]
  folders: ChatFolder[]
  activeChatId: string | null
  waitingForAiChatId: string | null  // Track which chat is waiting for AI response (persists across navigation)
  isLoading: boolean
  isConnected: boolean
  error: string | null

  // Chat actions
  setChats: (chats: Chat[]) => void
  addChat: (chat: Chat) => void
  updateChat: (chatId: string, updates: Partial<Chat>) => void
  removeChat: (chatId: string) => void
  setActiveChat: (chatId: string | null) => void
  getActiveChat: () => Chat | undefined

  // Organization helpers
  getPinnedChats: () => Chat[]
  getChatsInFolder: (folderId: string | null) => Chat[]
  getRecentChats: () => Chat[] // All chats sorted by updated_at

  // Folder actions
  setFolders: (folders: ChatFolder[]) => void
  addFolder: (folder: ChatFolder) => void
  updateFolder: (folderId: string, updates: Partial<ChatFolder>) => void
  removeFolder: (folderId: string) => void
  getPinnedFolders: () => ChatFolder[]
  getSubfolders: (parentFolderId: string | null) => ChatFolder[]

  // Message actions
  addMessage: (chatId: string, message: ChatMessage) => void
  updateMessage: (chatId: string, messageId: string, updates: Partial<Pick<ChatMessage, 'content' | 'isStreaming'>>) => void
  setMessages: (chatId: string, messages: ChatMessage[]) => void

  // Member actions
  setMembers: (chatId: string, members: ChatMember[]) => void
  addMember: (chatId: string, member: ChatMember) => void
  updateMember: (chatId: string, address: string, updates: Partial<ChatMember>) => void
  removeMember: (chatId: string, address: string) => void

  // Online presence
  setOnlineMembers: (chatId: string, addresses: string[]) => void
  updatePresence: (chatId: string, address: string, isOnline: boolean) => void

  // UI state
  setLoading: (loading: boolean) => void
  setConnected: (connected: boolean) => void
  setError: (error: string | null) => void
  clearUnread: (chatId: string) => void
  incrementUnread: (chatId: string) => void
  setWaitingForAiChatId: (chatId: string | null) => void
}

export const useChatStore = create<ChatState>()(
  persist(
    (set, get) => ({
      chats: [],
      folders: [],
      activeChatId: null,
      waitingForAiChatId: null,
      isLoading: false,
      isConnected: false,
      error: null,

      setChats: (chats) => set({ chats }),

      addChat: (chat) =>
        set((state) => ({
          chats: [chat, ...state.chats.filter((c) => c.id !== chat.id)],
        })),

      updateChat: (chatId, updates) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, ...updates } : c
          ),
        })),

      removeChat: (chatId) =>
        set((state) => ({
          chats: state.chats.filter((c) => c.id !== chatId),
          activeChatId:
            state.activeChatId === chatId ? null : state.activeChatId,
        })),

      setActiveChat: (chatId) => set({ activeChatId: chatId }),

      getActiveChat: () => {
        const state = get()
        return state.chats.find((c) => c.id === state.activeChatId)
      },

      // Organization helpers
      getPinnedChats: () => {
        const state = get()
        return state.chats
          .filter((c) => c && c.isPinned)
          .sort((a, b) => (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity))
      },

      getChatsInFolder: (folderId) => {
        const state = get()
        return state.chats
          .filter((c) => c && (folderId === null ? !c.folderId : c.folderId === folderId))
          .sort((a, b) => {
            // Pinned first, then by updated_at
            if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
            if (a.isPinned && b.isPinned) {
              return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
            }
            return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
          })
      },

      getRecentChats: () => {
        const state = get()
        return state.chats.filter(Boolean).sort((a, b) => {
          // Pinned first, then by updated_at
          if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
          if (a.isPinned && b.isPinned) {
            return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
          }
          return new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime()
        })
      },

      // Folder actions
      setFolders: (folders) => set({ folders }),

      addFolder: (folder) =>
        set((state) => ({
          folders: [folder, ...state.folders.filter((f) => f.id !== folder.id)],
        })),

      updateFolder: (folderId, updates) =>
        set((state) => ({
          folders: state.folders.map((f) =>
            f.id === folderId ? { ...f, ...updates } : f
          ),
        })),

      removeFolder: (folderId) =>
        set((state) => ({
          folders: state.folders.filter((f) => f.id !== folderId),
        })),

      getPinnedFolders: () => {
        const state = get()
        return state.folders
          .filter((f) => f.isPinned)
          .sort((a, b) => (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity))
      },

      getSubfolders: (parentFolderId) => {
        const state = get()
        return state.folders
          .filter((f) => parentFolderId === null ? !f.parentFolderId : f.parentFolderId === parentFolderId)
          .sort((a, b) => {
            // Pinned first, then by name
            if (a.isPinned !== b.isPinned) return a.isPinned ? -1 : 1
            if (a.isPinned && b.isPinned) {
              return (a.pinOrder ?? Infinity) - (b.pinOrder ?? Infinity)
            }
            return a.name.localeCompare(b.name)
          })
      },

      // Messages
      addMessage: (chatId, message) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const messages = c.messages || []
            // Avoid duplicates by ID
            if (messages.some((m) => m.id === message.id)) return c
            // For user messages, skip if there's already a matching message (optimistic or real)
            // This prevents duplicates from WebSocket echoing back our own messages
            if (message.role === 'user') {
              const hasMatchingMessage = messages.some((m) =>
                m.role === 'user' &&
                m.content === message.content &&
                // Only consider recent messages (within 30 seconds) as potential duplicates
                Math.abs(new Date(m.createdAt).getTime() - new Date(message.createdAt).getTime()) < 30000
              )
              // If there's already a matching message, skip adding this one
              // This keeps the optimistic message (which has attachments) instead of replacing with WebSocket message
              if (hasMatchingMessage) return c
            }
            return { ...c, messages: [...messages, message] }
          }),
        })),

      updateMessage: (chatId, messageId, updates) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              messages: (c.messages || []).map((m) =>
                m.id === messageId ? { ...m, ...updates } : m
              ),
            }
          }),
        })),

      setMessages: (chatId, messages) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            // Preserve attachments from local messages when merging with server data
            // Server doesn't store attachments, so we need to keep them from local optimistic messages
            const existingMessages = c.messages || []
            const mergedMessages = messages.map(msg => {
              const existingMsg = existingMessages.find(em =>
                (em.id === msg.id) ||
                (em.role === 'user' &&
                 em.content === msg.content &&
                 Math.abs(new Date(em.createdAt).getTime() - new Date(msg.createdAt).getTime()) < 30000)
              )
              // Preserve attachments from existing local message
              if (existingMsg?.attachments && existingMsg.attachments.length > 0) {
                return { ...msg, attachments: existingMsg.attachments }
              }
              return msg
            })
            return { ...c, messages: mergedMessages }
          }),
        })),

      // Members
      setMembers: (chatId, members) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, members } : c
          ),
        })),

      addMember: (chatId, member) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const members = c.members || []
            if (members.some((m) => m.address === member.address)) return c
            return { ...c, members: [...members, member] }
          }),
        })),

      updateMember: (chatId, address, updates) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              members: (c.members || []).map((m) =>
                m.address?.toLowerCase() === address?.toLowerCase()
                  ? { ...m, ...updates }
                  : m
              ),
            }
          }),
        })),

      removeMember: (chatId, address) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            return {
              ...c,
              members: (c.members || []).filter((m) => m.address !== address),
            }
          }),
        })),

      // Online presence
      setOnlineMembers: (chatId, addresses) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, onlineMembers: addresses } : c
          ),
        })),

      updatePresence: (chatId, address, isOnline) =>
        set((state) => ({
          chats: state.chats.map((c) => {
            if (c.id !== chatId) return c
            const current = c.onlineMembers || []
            const updated = isOnline
              ? current.includes(address) ? current : [...current, address]
              : current.filter((a) => a !== address)
            return { ...c, onlineMembers: updated }
          }),
        })),

      // UI state
      setLoading: (isLoading) => set({ isLoading }),
      setConnected: (isConnected) => set({ isConnected }),
      setError: (error) => set({ error }),

      clearUnread: (chatId) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId ? { ...c, unreadCount: 0 } : c
          ),
        })),

      incrementUnread: (chatId) =>
        set((state) => ({
          chats: state.chats.map((c) =>
            c.id === chatId
              ? { ...c, unreadCount: (c.unreadCount || 0) + 1 }
              : c
          ),
        })),

      setWaitingForAiChatId: (chatId) => set({ waitingForAiChatId: chatId }),
    }),
    {
      name: 'juice-chat',
      partialize: (state) => ({
        // Only persist chats, folders, and activeChatId, not loading/error states
        // Strip attachments from messages to avoid localStorage quota issues (base64 files are large)
        // Filter out null chats that can occur during test cleanup
        chats: state.chats.filter(Boolean).map(chat => ({
          ...chat,
          messages: chat.messages?.map(msg => {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            const { attachments, ...msgWithoutAttachments } = msg
            return msgWithoutAttachments
          }),
        })),
        folders: state.folders,
        activeChatId: state.activeChatId,
      }),
    }
  )
)

// Display types for UI components
export interface Attachment {
  id: string
  type: 'image' | 'document'
  name: string
  mimeType: string
  data: string  // base64
}

export interface Message {
  id: string
  role: 'user' | 'assistant'
  content: string
  timestamp?: number
  isStreaming?: boolean
  attachments?: Attachment[]
  senderName?: string
  senderAddress?: string
  createdAt?: string
  needsJuicyId?: boolean // Show "Add your Juicy ID" prompt instead of sender name
}

export interface Conversation {
  id: string
  title: string
  messages: Message[]
  createdAt: number
  updatedAt: number
}

